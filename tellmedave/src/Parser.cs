/* Tell Me Dave 2013-14, Robot-Language Learning Project
 * Code developed by - Dipendra Misra (dkm@cs.cornell.edu)
 * working in Cornell Personal Robotics Lab.
 * - Kejia Tao (kt454@cornell.edu)
 * Undergrad in Cornell CS major
 * 
 * More details - http://tellmedave.cs.cornell.edu
 * This is Version 2.0 - it supports data version 1.1, 1.2, 1.3
 */

/*  Notes for future Developers - 
 *    <no - note >
 */

/* Project Compton
 * Intellectual Property : Personal Robotics Group, Cornell University, Ithaca, NY
 * Aim : To learn controller programs from natural language instructions couple with visual cues*
 */


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Xml;

/* Developers : Dipendra Kumar Misra (dkm@cs.cornell.edu),
 * 
 * Note for Developers : Please comment your code, acknowledge
 * all dependencies and previous code. Use version control,
 * make functions small and name them properly. Comment should
 * be followed after every function, class and constructor declaration.*/

namespace ProjectCompton
{
    class Parser
    {
        /* Class Description : Parser class parses natural language instructions
         * into set of clauses. */

        // List of data-index along with parsed set of instances of the sentence and of the individual clauses
		private List<Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>>> labelledData = new List<Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>>>();
		public List<Tuple<Tuple<int, int>, Clause, List<Clause>>> unlabelledData{private set; get;}

		public List<Tuple<String,String,int,int>> rawData = new List<Tuple<string, string, int, int>>(); //user name, sentence, env, objective

        private XmlTextReader reader = null;
        private System.IO.StreamWriter writer = null;
		private System.IO.StreamReader ublReader = null;
        /* Alignment[i] = (a,b,c) means for the ith entry in parsedSentence, the alignment for the ath clause 
         * is given by (b,c) with the instructions sequence. I personally plan to use two things - 
         * 1. Alignment given by the user using the website
         * 2. Alignment generated by the IBM alignment model */

        private List<List<Tuple<int, int>>> alignment = new List<List<Tuple<int, int>>>(); 
        public List<Clause> ublClause = new List<Clause>();

        public List<Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>>> returnAllData()
        {
            /* Function Description : returns all the data*/
            return this.labelledData;
        }

        public List<List<Tuple<int, int>>> returnAllAlignment()
        {
            //Function Description: Returns the alignment data
            return this.alignment;
        }

        //Functions Related to Caching the Stanford Parser Data

        private Tuple<string, string> getNextDataFromXML()
        {
            /* Function Description : Get next data from XML. 
             * Get the next two values. */
            if (this.reader == null)
            {
				reader = new XmlTextReader(Constants.dataFolder + @"/parser_" + Constants.dataFileName);
                reader.Read();
            }

            String s1 = null, s2 = null;
            while (s1==null || s2==null)
            {
                switch (reader.NodeType)
                {
                    case XmlNodeType.Element: // The node is an element.
                        if (reader.Name.Equals("data1"))
                        {
                            reader.Read();
                            s1 = reader.Value;
                        }

                        if (reader.Name.Equals("data2"))
                        {
                            reader.Read();
                            s2 = reader.Value;
                        }
                        break;
                    case XmlNodeType.Text: //Display the text in each element.
                        /*if (s1 == null)
                            s1 = reader.Value;
                        else s2 = reader.Value; */
                        break;
                    case XmlNodeType.EndElement: //Display the end of the element.
                        break;
                }
                reader.Read();
            }

            return new Tuple<string, string>(s1,s2);
        }

        private void storeDataInXML(Tuple<string,string> data)
        {
            /* Function Description : Stores the data in an xml file */
            if (this.writer == null)
            {
				this.writer = new System.IO.StreamWriter (Constants.dataFolder + @"/parser_" + Constants.dataFileName, true);
                this.writer.WriteLine("<closure>");
            }
            this.writer.WriteLine("<data1>"+data.Item1+"</data1><data2>"+data.Item2+"</data2>");
            this.writer.Flush();
        }

        public void close()
        {
            /* Function Description : Add the delimeter to the closure file*/
            if (this.writer != null)
            {
                this.writer.WriteLine("</closure>");
                this.writer.Flush();
                this.writer.Close();
            }
        }

        public Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> getDataInformation(Tuple<int, int> data)
        {
            /* Function Description : return the data information from the parsedSentence structure*/
            foreach (Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> tmp in this.labelledData)
            {
                if (tmp.Item1.Item1 == data.Item1 && tmp.Item1.Item2 == data.Item2)
                    return tmp;
            }
            return null;
        }

        //Functions Related to Parsing

        public void parseLabelledData(Logger lg, List<Environment> envList)
        {
            /* Function Description : Parses everything in the data 
             * Version 3, uses the format specified in VEIL-500. It will parse
             * all the sentences in the data[xxx].xml file. The structure of the
             * data[xxxx].xml file is - 
             * <root>
             *      <point>
             *          <email>string</email>
             *          <hasLangID>integer</hasLangID>
             *          <objective_id>integer</objective_id>
             *          <scenario_id>integer</scenario_id>
             *          <sentence>string</sentence>
             *          <instruction>string</instruction>
             *      </point>
             *      ......
             * </root> */

			XmlTextReader reader = new XmlTextReader(Constants.dataFolder+@"/"+Constants.dataFileName);
			this.ublReader = new System.IO.StreamReader (Constants.UBLPath+"lambda.txt");
            String sentence = "", instruction = "";
            int scenarioID = -1, objectiveID = -1; //scenario ID defines environment like kitchen1, livingRoom12 etc. while objectiveID defines the objective like making ramen, clean room etc.
            Clause wholeClause = null;
            List<Instruction> instructions = null;
            List<Clause> individualClause = null;
			int count = 0;

			String sentenceCopy = null, email = null;


            while (reader.Read())
            {
                switch (reader.NodeType)
                {
                    case XmlNodeType.Element: // The node is an element.
                        if (reader.Name.Equals("point"))
                        {
                            wholeClause = new Clause();
                            //instructions = new List<Instruction>();
							instruction = "";
                            individualClause = new List<Clause>();
                        }
                        if (reader.Name.Equals("sentence"))
                        {
                            reader.Read();
                            sentence = reader.Value;
							sentenceCopy = sentence.ToString ();
                        }
                        if (reader.Name.Equals("instruction"))
                        {
                            reader.Read();
							instruction = /*reader.ReadInnerXml ();*/reader.Value;
							//if(!Constants.dataFolder.Equals("VEIL500"))
						    //	instructions = this.parseInstruction(instruction, individualClause, envList[scenarioID-1], lg);
                        }
                        if (reader.Name.Equals("scenario_id"))
                        {
                            reader.Read();
                            scenarioID = Int32.Parse(reader.Value);
                        }
                        if (reader.Name.Equals("objective_id"))
                        {
                            reader.Read();
                            objectiveID = Int32.Parse(reader.Value);
                        }
						if (reader.Name.Equals("email"))
						{
							reader.Read();
							email = reader.Value;
						}
					break;                        
					case XmlNodeType.EndElement: //Display the end of the element.
                        if (reader.Name.Equals("sentence"))
                        {
                            wholeClause = this.shallowParsing(sentence, individualClause, lg);
                            sentence = null;
                        }
                        if (reader.Name.Equals("instruction"))
                        {
                            instructions = this.parseInstruction(instruction, individualClause, envList[scenarioID-1], lg);
                        }
                        if (reader.Name.Equals("point"))
                        {
							count++;
							Console.WriteLine ("Labelled Point Number " + count);
                            Clause wholeClause_ = wholeClause;
                            if (instructions == null) //empty instruction sequence was found. Since empty instruction are collapsed, they are no detected earlier
                                instructions = this.parseInstruction("", individualClause, envList[scenarioID-1], lg);

                            List<Instruction> instructions_ = instructions.ToList();
                            List<Clause> individualClause_ = individualClause.ToList();

                            instructions.Clear();
                            instructions = null;

                            this.labelledData.Add(new Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>>
						                      (new Tuple<int, int>(scenarioID, objectiveID), wholeClause_, instructions_, individualClause_));

							if (sentenceCopy == null)
								sentenceCopy = "";
							this.rawData.Add (new Tuple<string, string, int, int> (email, sentenceCopy, scenarioID, objectiveID));
							sentenceCopy = null;
                        }
                        break;
                }
            }
			//this.parseLambdaExpression();
            this.close(); //Close the writer file which is being used for caching the data in a file
        }

		public void parseUnsupervisedData(Logger lg, List<Environment> envList)
		{
			/* Function Description : Parses all the unlabelled_data in the
			 * data[xxx].xml file. The structure of the file is - 
             * <root>
             *      <point>
             *          <email>string</email>
             *          <objective>integer</objective>
             *          <scenario>integer</scenario>
             *          <sentence>string</sentence>
             *      </point>
             *      ......
             * </root> */

			/* Constants.cacheReadParser = false;
			 * this.reader.Close (); */
			this.unlabelledData = new List<Tuple<Tuple<int, int>, Clause, List<Clause>>> ();

			XmlTextReader reader = new XmlTextReader(Constants.dataFolder+@"/unlabelled_" + Constants.dataFileName);

			String sentence = "";
			int scenarioID = -1, objectiveID = -1; //scenario ID defines environment like kitchen1, livingRoom12 etc. while objectiveID defines the objective like making ramen, clean room etc.
			Clause wholeClause = null;
			List<Clause> individualClause = null;
			int count = 0;

			while (reader.Read())
			{
				switch (reader.NodeType)
				{
					case XmlNodeType.Element: // The node is an element.
					if (reader.Name.Equals("point"))
					{
						wholeClause = new Clause();
						individualClause = new List<Clause>();
					}
					if (reader.Name.Equals("sentence"))
					{
						reader.Read();
						sentence = reader.Value;
					}
					if (reader.Name.Equals("scenario"))
					{
						reader.Read();
						scenarioID = Int32.Parse(reader.Value);
					}
					if (reader.Name.Equals("objective"))
					{
						reader.Read();
						objectiveID = Int32.Parse(reader.Value);
					}
					break;                        
					case XmlNodeType.EndElement: //Display the end of the element.
					if (reader.Name.Equals("sentence"))
					{
						wholeClause = this.shallowParsing(sentence, individualClause, lg);
						sentence = null;
					}
					if (reader.Name.Equals("point"))
					{
						count++;
						Console.WriteLine ("Unlabelled Point " + count);
						Clause wholeClause_ = wholeClause;
						List<Clause> individualClause_ = individualClause.ToList();
						this.unlabelledData.Add(new Tuple<Tuple<int, int>, Clause, List<Clause>>(
											  			new Tuple<int, int>(scenarioID, objectiveID), 
														wholeClause_, individualClause_));
					}
					break;
				}
			}
			//this.parseLambdaExpression();
			this.close(); //Close the writer file which is being used for caching the data in a file
		}

        private Clause shallowParsing(String sentence, List<Clause> individualClause, Logger lg)
        {
            /*Function Description: Parse the sentence or paragraph which has the format - 
              sentence : fragment1 | fragment2  ...... | fragmentk <br/><span ...> .....</span>
             * it creates two data-structures - one as a singel language for the entire sentence
             * which is stored in wholeClause while one as one language per fragment. When creating
             * language structure for each segment, we parse from scratch than use the parse tree of the
             * full sentence. A comparison with this approach can be tried. */

            /* Remove the <br/> ... part */
            int index = sentence.IndexOf("<");
            if (index != -1)
                sentence = sentence.Substring(0, index);

            //String textString = Processing.coelesceString(sentence);
            String sntc = "";
            for (int i = 0; i < sentence.Count(); i++)
            {
                if (sentence[i] != '|')
                    sntc = sntc + sentence[i];
            }
			
            List<Clause> sntcCLS = new List<Clause>();	
            String[] decomposing = sntc.Split(new char[] { '.' });

            //Invariantly : clauseArray.Count() == instructionArray.Count()
			foreach (String elem in decomposing)
            {
                if (elem.Count() == 0)
                    continue;

                String lexParse = this.callLexParserOnString(elem).Item2;
                if (lexParse.Length == 0) //To handle out of memory exception
                {
                    lg.writeToErrFile("Sentence "+elem+" is either empty or too long");
                    continue;
                }

                List<String> filteredOutput = this.filterParse(lexParse);
                Clause cls = this.generateCFL(filteredOutput[0]); //generate clause from the constituency parse tree

				Clause iterator = cls;
				for (int i=1; i<filteredOutput.Count(); i++) //altnerative clauses generated from topK parse tree are attached to each other
				{
					Clause altCls = this.generateCFL(filteredOutput[i]);
					iterator.alternativeParse = altCls;
					iterator = altCls;
				}

				if (cls != null) 
				{
					cls.sentence = elem; //this should be further segmented
					sntcCLS.Add (cls);  //add cls to final
				}
            }
			
			Clause sentenceRoot = this.connectCFL(sntcCLS);
			
            String[] clauseArray = sentence.Split(new char[] { '|' });
            for (int clsNo = 0; clsNo < clauseArray.Count(); clsNo++)
            {
                String lexParse = this.callLexParserOnString(clauseArray[clsNo]).Item2;
                if (lexParse.Length == 0) //To handle out of memory exception
                    continue;
                List<String> filteredOutput = this.filterParse(lexParse);
				Clause cls = this.generateCFL (filteredOutput[0]);

				if (cls != null) 
				{
					cls.sentence = clauseArray[clsNo];
					individualClause.Add(cls);
				}
            }
            return sentenceRoot;
        }

		public Clause shallowParsing(String text, Logger lg)
		{
			/* Function Description: Perform shallow parsing on this text and output clause */

			List<Clause> sntcCLS = new List<Clause>();	
			String[] decomposing = text.Split(new char[] { '.' });

			foreach (String elem in decomposing)
			{
				if (elem.Count() == 0)
					continue;

				String lexParse = this.callLexParserOnString(elem).Item2;
				if (lexParse.Length == 0) //To handle out of memory exception
				{
					lg.writeToErrFile("Sentence "+elem+" is either empty or too long");
					continue;
				}

				List<String> filteredOutput = this.filterParse(lexParse);
				Clause cls = this.generateCFL(filteredOutput[0]); //generate clause from the constituency parse tree

				Clause iterator = cls;
				for (int i=1; i<filteredOutput.Count(); i++) //altnerative clauses generated from topK parse tree are attached to each other
				{
					Clause altCls = this.generateCFL(filteredOutput[i]);
					iterator.alternativeParse = altCls;
					iterator = altCls;
				}

				if (cls != null) 
				{
					cls.sentence = elem; //this should be further segmented
					sntcCLS.Add (cls);  //add cls to final
				}
			}

			return this.connectCFL(sntcCLS);
		}

		private List<Instruction> parseInstruction(String instruction, List<Clause> individualClause, Environment env, Logger lg)
        {
            /* Function Description : Parses the instruction which have the following format-  
             * <span ...>_____</span><br/><span .....></span><br/><span .... >----</span> .... 
             * while doing this we ignore all span with meta-class attributes for the moment. */

            List<Instruction> instList = new List<Instruction>();
            List<Tuple<int, int>> alignment = new List<Tuple<int, int>>();
            int start = 0, end = 0; //they both go from [0..|Inst|-1] of their respective array
            XmlDocument doc = new XmlDocument();
            instruction = instruction.Replace("<br>", "<br/>");
            instruction = "<instruction>" + instruction + "</instruction>"; //added to avoid multiple root error
            doc.LoadXml(instruction);

            XmlNodeList elemList = doc.GetElementsByTagName("span");
            for (int i = 0; i < elemList.Count; i++)
            {
                String inst_ = elemList[i].InnerXml;
                inst_ = inst_.Trim();
				if (inst_.StartsWith("Store") || inst_.StartsWith("Time") || inst_.StartsWith("$$") || inst_.StartsWith("Respawn")|| inst_.StartsWith("respawn"))
                    continue;
				if (inst_.StartsWith ("Drop")) 
				{
					int openParen = inst_.IndexOf ('(');
					if (openParen != -1) 
					{
						int secondParen = inst_.IndexOf (')');
						double[] position = inst_.Substring (openParen + 1, secondParen - openParen - 1).Split(new char[]{','}).Select(x=>Double.Parse(x.Trim())).ToArray();
						int index = -1; 
						double distance = Double.PositiveInfinity;
						for(int objIndex=0; objIndex<env.objects.Count(); objIndex++)
						{
							/* Compute distance between position and object position, since most of the placeable objects cannot be
							 * moved so we can still use the initial states position. */
							if (env.objects[objIndex].affordances_.Contains ("IsPlaceableOn") || env.objects[objIndex].affordances_.Contains ("IsPlaceableIn")) 
							{
								double newDist = env.objects [objIndex].getL2Distance (position[0], position[1], position[2]);
								if(newDist < distance) //find closest object
								{
									distance = newDist;
									index = objIndex;
								}
								break;
							}
						}

						if (instList.Last ().getControllerFunction ().Equals ("release") && index != -1 && distance < 300) 
						{
							Instruction replacedInst = new Instruction ();
							String rel = "On";
							if (env.objects [index].affordances_.Contains ("IsPlaceableIn"))
								rel = "In";
							replacedInst.parse ("keep " + instList.Last ().getArguments () [0] + " " + rel + " " + env.objects [index].uniqueName, lg);
							instList.RemoveAt (instList.Count () - 1);
							instList.Add (replacedInst);
						} 
					}	
					continue;
				}
                else if (inst_.StartsWith("Change of Segment"))
                {
                    alignment.Add(new Tuple<int, int>(start, end - 1));
                    start = end;
                }
                else
                {
                    Instruction inst = new Instruction();
                    inst.parse(inst_, lg);
                    instList.Add(inst);
                    end++;
                }
            }

            if (alignment.Count() > individualClause.Count())
                lg.writeToErrFile("<p style='color:red'>Unexpected Error: More Change-Of-Segments than clauses.</p>");//Warning : throw new ApplicationException("Unexpected Error: More Change-Of-Segments than clauses. ");

            if (alignment.Count() < individualClause.Count()) //some clause may not be covered
            {
                //Warning : Users not accessing all the clause
                int diff = individualClause.Count() - alignment.Count();
                for (int d = 0; d < diff; d++)
                    alignment.Add(new Tuple<int, int>(end, end - 1)); //they are mapped as empty
            }

            
			for(int j=0; j<alignment.Count(); j++) 
			{
				Tuple<int,int> align = alignment[j];
				if (align.Item1 == instList.Count () && align.Item2 == align.Item1-1) 
					alignment [j] = new Tuple<int, int> (align.Item1-1,align.Item2-1);
				align = alignment[j];
				if(align.Item2>=instList.Count() || align.Item1>=instList.Count())
					throw new ApplicationException ("Improper Alignment Exception: Size of Instruction Sequence for the given case " + instList.Count ());
			}

			this.alignment.Add(alignment);
            return instList; //Note that, the alignments are atleast as many as the number of clauses. 
        }


        SyntacticTree makeTree(string parsedInstruction)
        {
            /*Function Description : Constructs a tree out of parsed instruction*/

            int counter = 0;
            SyntacticTree current = null, root=null;
            while (counter != parsedInstruction.Count())
            {
                if (parsedInstruction[counter] == '(') //start of a new node
                {
                    //create a new child and move down
                    if (current == null)
                    {
                        current = new SyntacticTree();
                        root = current;
                    }
                    else current = current.createAndAddChild();
                    counter++;
                }
                else if (parsedInstruction[counter] == ')')
                {
                    //go to parent
                    current = current.giveParent();
                    counter++;
                }
                else if (parsedInstruction[counter] == ' ')
                {
                    counter++;
                }
                else
                {
                    //it is some word
                    string word = "";
                    while (counter < parsedInstruction.Count() && parsedInstruction[counter] != '(' && parsedInstruction[counter] != ' ' && parsedInstruction[counter] != ')')
                    {
                        word = word + parsedInstruction[counter];
                        counter++;
                    }
                    current.addDefinition(word);
                }
            }
            return root;
        }

        public Clause generateCFL(String sentence)
        {
            /* Function Descirption : Takes a sentence and creates CFL datastructure of it */
            if (sentence.Count() == 0)
                return null;
            SyntacticTree decompose = this.makeTree(sentence);
			//Step 1 : Find verb conditions
            List<Clause> vbc = new List<Clause>(); //the list of verb conditions
			List<SyntacticTree> vbcSyn = decompose.findVerbCondition(vbc);
			this.ublClause.Concat(vbc);
			foreach (Clause c in vbc) 
			{
				c.condition = this.ublReader.ReadLine ();
			}
            if (vbcSyn.Count != 0)//delete verbConditions from decompose tree
			{
                foreach (SyntacticTree child in vbcSyn)
                {
                    child.giveParent().deleteChild(child);
                }
			}

			//Step 2 : Find verbs
            List<Clause> cls = new List<Clause>();
			decompose.verbify(cls);

            //Step 3 : Assign Noun phrasess and verb specifications to verbs
            decompose.attachNoun(cls);

			//Step 4 : Find relation and record all NounPhrases
            List<NounPhrase> nounPhraseList=new List<NounPhrase>();
			foreach (Clause cl in cls)
			{
                cl.findRelation();
				nounPhraseList.AddRange(cl.lngObj);
			}


			//Step 5 : Create a control-flow language tree
			if (cls.Count==0)
			{

				return null;
			}
			Clause root = cls[0];
			List<Clause> leaves = new List<Clause>();
			leaves.Add(cls[cls.Count-1]);
			for (int i=1;i<cls.Count;i++)
			{
				cls[i].parent.Add(cls[i-1]);
				cls[i-1].children.Add(cls[i]);
			}
			for (int j=vbc.Count-1;j>=0;j--)
			{
				if (Global.isPresent(Global.conditionIf,vbc[j].conditionName)||Global.isPresent(Global.conditionFor,vbc[j].conditionName)||Global.isPresent(Global.conditionAfter,vbc[j].conditionName)||Global.isPresent(Global.conditionUntil,vbc[j].conditionName))
				{
					root.parent.Add(vbc[j]);
					vbc[j].children.Add(root);
					root = vbc[j];
					Clause end = new Clause("end "+vbc[j].conditionName);
					end.parent.Add(leaves[0]);
					leaves[0].children.Add(end);
					leaves[0]=end;
					root.addConditionScope(root,end);
				}
			}
            return root;
        }
		
		public Clause connectCFL(List<Clause> cfl)
		{
           /*Function Description : connects cfl trees to be one big cfl tree,
			returns the root Clause*/
			if (cfl.Count == 0) 
				return null;

			else if (cfl.Count == 1) 
				return cfl [0];

			for (int i=1; i<cfl.Count; i++)
			{
				foreach (SyntacticTree vbc in cfl[i].verbSpecification)
				{
					if (Global.isPresent(Global.conditionElse, vbc.getName()))// cfl[i] contains "otherwise" or "else"
					{
						if (Global.isPresent(Global.conditionIf, cfl[i-1].conditionName))
						{
							cfl[i].parent.Add(cfl[i-1]);
							cfl[i-1].children.Add(cfl[i]);
							Clause end = cfl[i-1].conditionEnd;
							Clause leaf = cfl [i].findLeaf ();
							end.parent.Add(leaf);
							leaf.children.Add(end);
						}
						break;
					}
				}
                if (cfl[i].parent.Count > 0)
					continue;

				Clause last = cfl [i-1].findLeaf ();
				cfl[i].parent.Add(last);
				last.children.Add(cfl[i]);
			}
			return cfl[0];
		}

        public Tuple<String, String> callLexParserOnString(String data)
        {
            /*Function Description : Creates a temporary file and writes
             * the string onto it and then parses it using Stanford Parser.
             * It then deltes that temporary file*/
            Tuple<String, String> ans=null;
			if (Constants.cacheReadParser)
            {
                ans = getNextDataFromXML();
            }
            else
            {
                data = data.Trim();
                if (!data.EndsWith("."))
                    data = data + '.';
                Random randomizer = new Random();
                int key = randomizer.Next(1000);
                String path = Constants.rootPath + "TempFile" + key.ToString() + ".txt";
                System.IO.StreamWriter file = new System.IO.StreamWriter(path, true);

                file.Write(data);
                file.Flush();
                file.Close();
                ans = callLexParser("TempFile" + key.ToString() + ".txt");
                System.IO.File.Delete(path);
				if(Constants.opmode != OpMode.Online)
	               this.storeDataInXML(ans); //save the response in the xml file
            }
            return ans;
        }

        public Tuple<String,String> callLexParser(String relFileName)
        {
            //Function Description : Calls Stanford Parser on the text file

            if(!System.IO.File.Exists(Constants.rootPath + relFileName))
            {
                //no such file exists
                return new Tuple<String, String>("No Such File Exists", null);
            }

            String parserFile = "lexparser.bat";
            if (Constants.usingLinux)
                parserFile = "lexparser.sh";

            if (System.IO.File.Exists(Constants.rootPath + @"StanfordParser/" + parserFile))
            {
                Process proc = new Process();
                proc.StartInfo.WorkingDirectory = Constants.rootPath + "StanfordParser/";
                proc.StartInfo.FileName = Constants.rootPath + @"StanfordParser/" + parserFile;
                proc.StartInfo.RedirectStandardError = true;
                proc.StartInfo.RedirectStandardOutput = true;
                proc.StartInfo.UseShellExecute = false;

                proc.StartInfo.Arguments = string.Format("../"+relFileName);//this is argument
                proc.StartInfo.CreateNoWindow = false;
                proc.Start();
                proc.WaitForExit();

                String output1 = proc.StandardError.ReadToEnd();
                proc.WaitForExit();
                String output2 = proc.StandardOutput.ReadToEnd();
                proc.WaitForExit();

                Tuple<String, String> ans = new Tuple<String, String>(output1, output2);
                return ans;
            }
            else 
            {
                //parser cannot be found
                return new Tuple<String, String>("Parse Cannot be Located", null);
            }
        }

        public List<String> filterParse(String entire)
        {
            /* Function Description: Filters the parse from the entire parser output */
			List<String> filteredOutput = new List<String> ();
			entire = entire.Replace ('\r', ' ');
			entire = entire.Replace ('\n', ' ');
			int i = 0;

			for (int parse = 0; parse< Constants.topKParse/*+1*/; parse++) 
			{
				bool started = true;
				int count = 0, start=0;

				while (i<entire.Count() && (count > 0 || started)) 
				{
					if (entire.Substring(i).StartsWith("(ROOT ")) 
					{
						started = false;
						start = i;
					}

					if(entire[i]=='(')
						count++;
					else if (entire [i] == ')') 
						count--;
					i++;
				}

				//it has to end on ')' hence we take it till there
				if (entire.Count () == 0)
					filteredOutput.Add("");
				else
					filteredOutput.Add(entire.Substring (start, i + 1-start));
			}

			if(Constants.topKParse>1)
				filteredOutput.RemoveAt (0); //the first parse is repeated once again
			return filteredOutput;
        }

		public void parseLambdaExpression()
		{
			/* Function Description: Parse the sentences in Test file into lambda Expression with UBL
			 * and add lambda expression to the condition field to clauses in this.ublClause */

			if (!Constants.cacheReadUBLParser)
            {
                System.Diagnostics.Process process = new System.Diagnostics.Process();
                System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
                startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
                startInfo.FileName = "cmd.exe";
                startInfo.Arguments = "/C cd " + Constants.UBLPath + "./UBL/experiments/new\n./rundev.pl en 0";
                process.StartInfo = startInfo;
                process.Start();
            }

			List<String> lines=  System.IO.File.ReadLines(Constants.UBLPath+"UBL/experiments/new/run.dev.en.0.0").ToList();
			int lineCount =  lines.Count-1;
			int clauseCount = this.ublClause.Count - 1;
			bool found = false;
            while (lines[lineCount].IndexOf("0: ==================(0 -- 0)") == -1 && lineCount >= 0)
            {
                string line = lines[lineCount];
                if (found == true)
                {
                    int indexLeft = line.IndexOf("[");
                    int indexRight = line.IndexOf("]");
                    this.ublClause[clauseCount].condition = line.Substring(indexLeft + 1, indexRight);
					Console.WriteLine("Adding the UBL Condition "+this.ublClause[clauseCount].condition);
                    found = false;
                    clauseCount--;
                }
                else if (line.IndexOf("[LexEntries and scores:") > -1)
                {
                    found = true;
                }
                lineCount--;
            }
		}

        //Functions Related to Storing the Parsed Data

        public void storeAll(Logger lg)
        {
            // Function Description: Store the data in a html file
            lg.writeToParserData("<root>");
            foreach (Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> ps in this.labelledData)
            {
                lg.writeToParserData("<point>");
                //store clause
                if (ps.Item2 != null)
                    ps.Item2.storeXML(lg);
                //store instruction
                String inst_ = "<Instructions>";
                foreach (Instruction inst in ps.Item3)
                    inst_ = inst_ + "<Instruction>" + inst.getName() + "</Instruction>";
                inst_ = inst_ + "</Instructions>";
                lg.writeToParserData(inst_);
                lg.writeToParserData("</point>");
            }
            lg.writeToParserData("</root>");
        }

		public void storeVEILTemplates(List<VerbProgram> veil, Logger lg)
		{
			//Function Description: Temporary design for Ashwin's project
			//lg.writeToParserData ("<root>");
			foreach (VerbProgram vp  in veil) 
			{
				foreach (LexicalEntry vtmp in vp.getProgram()) 
				{
					lg.writeToParserData ("<veil>");
					//store clause
					vtmp.cls_.storeXML (lg);
					//store environment
					lg.writeToParserData ("<Environment>");
					foreach (Object obj in vtmp.env_.objects) 
						obj.storeXML (lg);
					lg.writeToParserData ("<Edges>");
					foreach (Tuple<Object,Object,SpatialRelation> rel in vtmp.env_.relationshipMatrix)
						lg.writeToParserData (rel.Item1.uniqueName + " " + rel.Item3.ToString () + " " + rel.Item2.uniqueName);
					lg.writeToParserData ("</Edges>");
					lg.writeToParserData ("</Environment>");
					//store instruction
					lg.writeToParserData ("<Instructions>");
					foreach (Instruction inst in vtmp.instOld)
						lg.writeToParserData ("<Instruction>" + inst.getName () + "</Instruction>");
					lg.writeToParserData ("</Instructions>");
					lg.writeToParserData ("</veil>");
					lg.incrementParserFile ();
				}
			}
			//lg.writeToParserData ("</root>");
		}

		public double getParserAccuracy(List<int> test)
		{
			//Function Description: kejia, define you metrics and other parts here
			System.IO.StreamReader testReader = new System.IO.StreamReader(Constants.rootPath+"parsesTest.txt");
			testReader.ReadLine ();
			int totalScore = 0;
			int accurateScore = 0;
			for (int i = 0; i < test.Count; i++) //for each sentence
			{
				string entry = testReader.ReadLine ();
				entry.Replace ("<parse>","");
				entry.Replace ("</parse>","");
				string[] clausesTest = entry.Split (new string[]{";"},StringSplitOptions.RemoveEmptyEntries);
				List<Clause> clauses = this.labelledData[test [i]].Item4;
				foreach (string clT in clausesTest) // for each verb clause, compare the accuracy
				{
					string verbT = clT.Split (new string[]{"["},StringSplitOptions.RemoveEmptyEntries) [0].Trim();
					string[] nounsT = clT.Split (new string[]{"["},StringSplitOptions.RemoveEmptyEntries) [1].Split (new string[]{"relation"},StringSplitOptions.RemoveEmptyEntries) [0].Split (new string[]{"|"},StringSplitOptions.RemoveEmptyEntries);
					totalScore = totalScore + 1 + nounsT.Count();
					foreach(Clause c in clauses) 
					{
						if (verbT.Equals (c.verb.getName(), StringComparison.InvariantCultureIgnoreCase)) // find clauses with same leading verbs
						{
							accurateScore += 1;
							foreach (string n in nounsT) //compare nouns if verbs coincide
							{
								n.Trim();
								foreach (NounPhrase np in c.lngObj) 
								{
									if (n.Equals (np.getNPhraseSen(np.getOriginalNounPhrase()).Trim(), StringComparison.InvariantCultureIgnoreCase)) 
									{
										accurateScore += 1;
										break;
									}
								}
							}
							break;
						}
					}
				}
			}
			Console.Write ("accuracy" + (double)accurateScore / (double)totalScore);
			return (double) accurateScore/(double)totalScore;
		}
    }
}
